clc; % Clear the command window
clear all; % Clear all variables from the workspace
%% System Information
% Define generator cost data: [Fixed cost (A), Linear cost (Beta), Quadratic cost
(Gamma)]
data = [510 7.2 0.00142; % Generator 1 parameters
310 7.85 0.00194; % Generator 2 parameters
18 7.97 0.0082]; % Generator 3 parameters

% Extract parameters from the data matrix
A = data(:, 1); % Fixed cost for each generator
Beta = data(:, 2); % Linear cost coefficients
G = data(:, 3); % Quadratic cost coefficients

% Power demand
PD = 800; % Total power demand in MW

% Define maximum and minimum generation limits for each generator
Pmax = [600, 400, 200]; % Maximum power output for each generator
Pmin = [150, 100, 50]; % Minimum power output for each generator

% User inputs the initial value of lambda (Lagrange multiplier)
L = input('Enter the value of lambda='); % Incremental cost

% Tolerance and initialization for the iterative process
E = 0.0001; % Tolerance for stopping criteria
Pdel = 1; % Initial power mismatch
iter = 0; % Counter for iterations

% Iterative process to adjust generator outputs and lambda

while abs(Pdel) > E
iter = iter + 1; % Increment iteration counter

% Power generation calculation
for i = 1:3
% Calculate power generated by each generator without losses
P(i) = (L - Beta(i)) / (2 * G(i));

% Check upper limit for power generation
P(i) = min(P(i), Pmax(i));
% Check lower limit for power generation
P(i) = max(P(i), Pmin(i));
end

% Store generated power for each generator
P1gen(iter) = P(1);
P2gen(iter) = P(2);
P3gen(iter) = P(3);

% Calculate power mismatch
Pdel = PD - sum(P); % Difference between demand and generated power

% Calculate total cost for each generator
for m = 1:3
C(m) = A(m) + (Beta(m) * P(m)) + (G(m) * (P(m)^2)); % Total cost for each
generator
end
Cost(iter) = sum(C); % Total cost at this iteration
Psum = sum(P); % Total generated power

% Calculate the correction in Lambda and its update
f = 0; % Initialize variable for the sum of inverse gradients
for i = 1:3
f = f + (1 / (2 * G
(i))); % Calculate the sum of inverse gradients
end

% Calculate change in lambda
del_l = abs(Pdel / f);

% Update lambda based on the total generated power
if Psum > PD
L = L - del_l / 2; % Decrease lambda if total generation exceeds demand
else
L = L + del_l / 2; % Increase lambda if total generation is less than
demand
end

% Store lambda value for each iteration
Lambda(iter) = L;
end

% Display final results
disp(['Final Lambda: ', num2str(L)]);
disp(['Total Cost: ', num2str(Cost(iter))]);
disp('Generated Power: ');
disp(P);

% Plotting the cost convergence
figure; % Create a new figure
plot(Cost); % Plot cost against iterations

xlabel('Number of Iterations'); % Label for x-axis
ylabel('Cost ($)'); % Label for y-axis
title('Convergence Plot'); % Title of the plot

% Display all results in a table format
result = [Lambda', P1gen', P2gen', P3gen', Cost']; % Compile results
disp('Iterations, Lambda, P1, P2, P3, Cost');
disp(result); % Display results in the command window